/*
 * Copyright 2018 Philipp Salvisberg <philipp.salvisberg@trivadis.com>
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.utplsql.sqldev.runner;

import java.awt.Dimension;
import java.awt.Toolkit;
import java.sql.Connection;
import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Date;
import java.util.List;
import java.util.UUID;
import java.util.logging.Logger;

import javax.swing.JFrame;

import org.utplsql.sqldev.dal.RealtimeReporterDao;
import org.utplsql.sqldev.dal.RealtimeReporterEventConsumer;
import org.utplsql.sqldev.model.DatabaseTools;
import org.utplsql.sqldev.model.runner.PostRunEvent;
import org.utplsql.sqldev.model.runner.PostSuiteEvent;
import org.utplsql.sqldev.model.runner.PostTestEvent;
import org.utplsql.sqldev.model.runner.PreRunEvent;
import org.utplsql.sqldev.model.runner.PreSuiteEvent;
import org.utplsql.sqldev.model.runner.PreTestEvent;
import org.utplsql.sqldev.model.runner.RealtimeReporterEvent;
import org.utplsql.sqldev.model.runner.Run;
import org.utplsql.sqldev.model.runner.Test;
import org.utplsql.sqldev.resources.UtplsqlResources;
import org.utplsql.sqldev.ui.runner.RunnerFactory;
import org.utplsql.sqldev.ui.runner.RunnerPanel;
import org.utplsql.sqldev.ui.runner.RunnerView;

public class UtplsqlRunner implements RealtimeReporterEventConsumer {
    private static final Logger logger = Logger.getLogger(UtplsqlRunner.class.getName());

    private List<String> pathList;
    private String connectionName;
    private Connection producerConn;
    private Connection consumerConn;
    private final String reporterId = UUID.randomUUID().toString().replace("-", "");
    private Run run;
    private RunnerPanel panel;
    private Thread producerThread;
    private Thread consumerThread;

    public UtplsqlRunner(final List<String> pathList, final String connectionName) {
        this.pathList = pathList;
        setConnection(connectionName);
    }

    /**
     * this constructor is intended for tests only
     */
    public UtplsqlRunner(final List<String> pathList, final Connection producerConn, final Connection consumerConn) {
        this.pathList = pathList;
        this.producerConn = producerConn;
        this.consumerConn = consumerConn;
    }

    private void setConnection(final String connectionName) {
        if (connectionName == null) {
            throw new NullPointerException("Cannot initialize a RealtimeConsumer without a ConnectionName");
        } else {
            producerConn = DatabaseTools.cloneConnection(connectionName);
            consumerConn = DatabaseTools.cloneConnection(connectionName);
        }
        this.connectionName = connectionName;
    }

    public void dispose() {
        // running in SQL Developer
        DatabaseTools.closeConnection(producerConn);
        DatabaseTools.closeConnection(consumerConn);
    }

    @Override
    public void process(final RealtimeReporterEvent event) {
        logger.fine(() -> event.toString());
        // dynamic dispatching code originally generated by Xtend
        if (event instanceof PostRunEvent) {
            doProcess((PostRunEvent) event);
        } else if (event instanceof PostSuiteEvent) {
            doProcess((PostSuiteEvent) event);
        } else if (event instanceof PostTestEvent) {
            doProcess((PostTestEvent) event);
        } else if (event instanceof PreRunEvent) {
            doProcess((PreRunEvent) event);
        } else if (event instanceof PreSuiteEvent) {
            doProcess((PreSuiteEvent) event);
        } else if (event instanceof PreTestEvent) {
            doProcess((PreTestEvent) event);
        } else {
            throw new IllegalArgumentException("Unhandled parameter types: " + Arrays.asList(event).toString());
        }
    }

    private String getSysdate() {
        final Date dateTime = new Date(System.currentTimeMillis());
        final SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSS'000'");
        return df.format(dateTime);
    }

    private void initRun() {
        run = new Run(reporterId, connectionName, pathList);
        run.setStartTime(getSysdate());
        run.getCounter().setDisabled(0);
        run.getCounter().setSuccess(0);
        run.getCounter().setFailure(0);
        run.getCounter().setError(0);
        run.getCounter().setWarning(0);
        run.setInfoCount(0);
        run.setTotalNumberOfTests(-1);
        run.setCurrentTestNumber(0);
        run.setStatus(UtplsqlResources.getString("RUNNER_INITIALIZING_TEXT"));
        panel.setModel(run);
        panel.update(reporterId);
    }
    
    private void doProcess(final PreRunEvent event) {
        run.setTotalNumberOfTests(event.getTotalNumberOfTests());
        run.put(event.getItems());
        run.setStatus(UtplsqlResources.getString("RUNNER_RUNNING_TEXT"));
        panel.update(reporterId);
    }

    private void doProcess(final PostRunEvent event) {
        run.setStartTime(event.getStartTime());
        run.setEndTime(event.getEndTime());
        run.setExecutionTime(event.getExecutionTime());
        run.setErrorStack(event.getErrorStack());
        run.setServerOutput(event.getServerOutput());
        run.setStatus(UtplsqlResources.getString("RUNNER_FINNISHED_TEXT"));
        panel.update(reporterId);
    }

    private void doProcess(final PreSuiteEvent event) {
        // ignore
    }

    private void doProcess(final PostSuiteEvent event) {
        final Test test = run.getCurrentTest();
        // Errors on suite levels are reported as warnings by the utPLSQL framework, 
        // since an error on suite level does not affect a status of a test.
        // It is possible that the test is OK, but contains error messages on suite level(s)
        // Populating test.errorStack would be a) wrong and b) redundant
        if (event.getWarnings() != null) {
            if (test.getCounter().getWarning() == 0) {
                test.getCounter().setWarning(1);
                test.getCounter().setWarning(run.getCounter().getWarning() + 1);
            }
            StringBuilder sb = new StringBuilder();
            if (test.getWarnings() != null) {
                sb.append(test.getWarnings());
                sb.append("\n\n");
            }
            sb.append("For suite ");
            sb.append(event.getId());
            sb.append(":\n\n");
            sb.append(event.getWarnings());
            test.setWarnings(sb.toString());
        }
        if (event.getServerOutput() != null) {
            if (test.getServerOutput() == null) {
                run.setInfoCount(run.getInfoCount() + 1);
            }
            StringBuilder sb = new StringBuilder();
            if (test.getServerOutput() != null) {
                sb.append(test.getServerOutput());
                sb.append("\n\n");
            }
            sb.append("For suite ");
            sb.append(event.getId());
            sb.append(":\n\n");
            sb.append(event.getServerOutput());
            test.setServerOutput(sb.toString());
        }
        panel.update(reporterId);
    }

    private void doProcess(final PreTestEvent event) {
        final Test test = run.getTest(event.getId());
        if (test == null) {
            logger.severe(() -> "Could not find test id \"" + event.getId() + "\" when processing PreTestEvent "
                    + event.toString() + ".");
        } else {
            test.setStartTime(getSysdate());
        }
        run.setStatus(event.getId() + "...");
        run.setCurrentTestNumber(event.getTestNumber());
        run.setCurrentTest(test);
        panel.update(reporterId);
    }

    private void doProcess(final PostTestEvent event) {
        final Test test = run.getTest(event.getId());
        if (test == null) {
            logger.severe(() -> "Could not find test id \"" + event.getId() + "\" when processing PostTestEvent "
                    + event.toString() + ".");
        } else {
            test.setStartTime(event.getStartTime());
            test.setEndTime(event.getEndTime());
            test.setExecutionTime(event.getExecutionTime());
            test.setCounter(event.getCounter());
            test.setErrorStack(event.getErrorStack());
            test.setServerOutput(event.getServerOutput());
            if (test.getServerOutput() != null) {
                run.setInfoCount(run.getInfoCount() + 1);
            }
            test.setFailedExpectations(event.getFailedExpectations());
            test.setWarnings(event.getWarnings());
            if (test.getWarnings() != null) {
                test.getCounter().setWarning(1);
            } else {
                test.getCounter().setWarning(0);
            }
            run.getCounter().setWarning(run.getCounter().getWarning() + test.getCounter().getWarning());
        }
        run.getCounter().setDisabled(run.getCounter().getDisabled() + event.getCounter().getDisabled());
        run.getCounter().setSuccess(run.getCounter().getSuccess() + event.getCounter().getSuccess());
        run.getCounter().setFailure(run.getCounter().getFailure() + event.getCounter().getFailure());
        run.getCounter().setError(run.getCounter().getError() + event.getCounter().getError());
        panel.update(reporterId);
    }

    private void produce() {
        try {
            logger.fine(() -> "Running utPLSQL tests and producing events via reporter id " + reporterId + "...");
            final RealtimeReporterDao dao = new RealtimeReporterDao(producerConn);
            dao.produceReport(reporterId, pathList);
            logger.fine(() -> "All events produced for reporter id " + reporterId + ".");
        } catch (Exception e) {
            logger.severe(() -> "Error while producing events for reporter id " + reporterId + ": "
                    + (e != null ? e.getMessage() : "???"));
        }
    }

    private void consume() {
        try {
            logger.fine(() -> "Consuming events from reporter id " + reporterId + " in realtime...");
            final RealtimeReporterDao dao = new RealtimeReporterDao(consumerConn);
            dao.consumeReport(reporterId, this);
            logger.fine(() -> "All events consumed.");
        } catch (Exception e) {
            logger.severe(() -> "Error while consuming events for reporter id " + reporterId + ": "
                    + (e != null ? e.getMessage() : "???"));
        }
        if (run.getTotalNumberOfTests() < 0) {
            run.setStatus(UtplsqlResources.getString("RUNNER_NO_TESTS_FOUND_TEXT"));
            run.setExecutionTime(Double.valueOf(System.currentTimeMillis() - Double.valueOf(run.getStart())) / 1000);
            run.setEndTime(getSysdate());
            run.setTotalNumberOfTests(0);
            panel.update(reporterId);
        }
        if (isRunningInSqlDeveloper()) {
            dispose();
        }
    }

    private boolean isRunningInSqlDeveloper() {
        return (connectionName != null);
    }

    private boolean initGUI() {
        RunnerView dockable = null;
        if (isRunningInSqlDeveloper() && (dockable = RunnerFactory.getDockable()) == null) {
            logger.severe(() -> "Error getting utPLSQL dockable. Cannot run utPLSQL test.");
            return false;
        } else {
            if (isRunningInSqlDeveloper() && dockable != null) {
                RunnerFactory.showDockable();
                panel = dockable.getRunnerPanel();
            } else {
                final JFrame frame = new JFrame("utPLSQL Runner Panel");
                frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
                panel = new RunnerPanel();
                frame.add(panel.getGUI());
                frame.setPreferredSize(new Dimension(600, 800));
                frame.pack();
                final Dimension dim = Toolkit.getDefaultToolkit().getScreenSize();
                frame.setLocation(dim.width / 2 - frame.getSize().width / 2,
                        dim.height / 2 - frame.getSize().height / 2);
                frame.setVisible(true);
            }
            initRun();
            return true;
        }
    }

    public void runTestAsync() {
        // start tests when the GUI has been successfully initialized.
        if (initGUI()) {
            // the consumer
            consumerThread = new Thread(() -> consume());
            consumerThread.setName("realtime consumer");
            consumerThread.start();
            // avoid concurrency on output header table to fix issue #80
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
            // the producer
            producerThread = new Thread(() -> produce());
            producerThread.setName("realtime producer");
            producerThread.start();
        }
    }

    public Thread getProducerThread() {
        return producerThread;
    }

    public Thread getConsumerThread() {
        return consumerThread;
    }
}
